<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>The Nature of Code</title>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
	<script type="text/javascript" src="/book/javascripts/codeprocessing.js"></script>
	<script type="text/javascript" src="/book/processingjs/processing.js"></script>
  <script type="text/javascript" src="/book/processingjs/lazyloading.js"></script>
  <script type="text/javascript" src="/book/javascripts/sketchControls.js"></script>
  <script type="text/javascript" src="/book/javascripts/jquery.fixed.js"></script>

  <script type="text/javascript" charset="utf-8">
    $(document).ready(function(){
      $('#toc-list').fixed({'top':'8'});
      $('#nav-bar-wrap').fixed({'top':'8'});

      $('span.c1').each(function(){ addStylesToCodeLines($(this)); });
      // $('code').each(function(){ inlineComments($(this)); });
      $('div.source-code').each(function(){ setRawCodeHeight($(this)); });
      $('a.toggle').click(function(){ toggleCodeDisplay($(this)); return false; });
    });
  </script>
	<link rel="stylesheet" href="/book/stylesheets/fonts.css" type="text/css">
	<link rel="stylesheet" href="/book/stylesheets/html.css" type="text/css">
	<link rel="stylesheet" href="/book/stylesheets/code-html.css">

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34673170-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<script>

    window.onload= function() {
      offsetUps = document.getElementsByClassName('offset-up');
      for(var i=0; i < offsetUps.length; i++) {
        var element = offsetUps[i];
        var comment = element.getElementsByClassName('code-comment')[0];
        var height = comment.offsetHeight;
        comment.style.top = '-' + (height) +  'px';
      }
    };
</script>

</head>
<body>

  <div id="navigator">
    <div id="navigator-inner">
      <div id='nav-bar-wrap'>
        <div id="mask"></div>
        <div id="nav-bar">
          <h1><a href="/">THE <strong>NATURE</strong> OF CODE</a></h1>
          <h2>by Daniel Shiffman</h2>
          <a id="purchase-link" href="/">Buy this book in print</a> <a id="purchase-link" href="/">Buy this book as PDF</a>
        </div>
      </div>
      <div id="toc-holder">
        <div id="toc-list">
          <ul>
            <li><a href="/book/">Welcome</a></li>
            <li><a href="/book/acknowledgments">Acknowledgments</a></li>
            <li><a href="/book/dedication">Dedication</a></li>
            <li><a href="/book/preface">Preface</a></li>
            <li><a href="/book/introduction">Introduction</a></li>
            <li><a href="/book/chapter-1-vectors">1.  Vectors</a></li>
            <li><a href="/book/chapter-2-forces">2.  Forces</a></li>
            <li><a href="/book/chapter-3-oscillation">3.  Oscillation</a></li>
            <li><a href="/book/chapter-4-particle-systems">4.  Particle Systems</a></li>
            <li><a href="/book/chapter-5-physics-libraries">5.  Physics Libraries</a></li>
            <li><a href="/book/chapter-6-autonomous-agents">6.  Autonomous Agents</a></li>
            <li><a href="/book/chapter-7-cellular-automata">7.  Cellular Automata</a></li>
            <li><a href="/book/chapter-8-fractals">8.  Fractals</a></li>
            <li><a href="/book/chapter-9-the-evolution-of-code">9.  The Evolution of Code</a></li>
            <li><a href="/book/chapter-10-neural-networks">10.  Neural Networks</a></li>
            <li><a href="/book/further-reading">Further Reading</a></li>
            <li><a href="/book/index">Index</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <div id="top">
    <div id="header">
      <h1><a href="/">The <strong>Nature</strong> of Code</a></h1>
      <h2>Daniel Shiffman</h2>
    </div>
  </div>

  <div id="middle">

  	<div id="container">
  		<a id="_chapter_8_fractals" style="display: block;"></a><h2 id="chapter-8-fractals">Chapter 8.  Fractals</h2>
<blockquote class='long-quote'>
“Pathological monsters! cried the terrified mathematician<br/>
Every one of them a splinter in my eye<br/>
I hate the Peano Space and the Koch Curve<br/>
I fear the Cantor Ternary Set<br/>
The Sierpinski Gasket makes me wanna cry<br/>
And a million miles away a butterfly flapped its wings<br/>
On a cold November day a man named Benoit Mandelbrot was born”<br/>
<span class="attribution">
— Jonathan Coulton, lyrics from “Mandelbrot Set”
</span>
</blockquote><p><a id="fractals-82d5b950-253f-0130-bd48-7cd1c3f718ad" style="display: block;"></a><a id="natural-phenomenafractals-82d5d490-253f-0130-bd49-7cd1c3f718ad" style="display: block;"></a></p>
<p><a id="euclid-82d5f520-253f-0130-bd4a-7cd1c3f718ad" style="display: block;"></a><a id="euclidean-geometry-82d60e80-253f-0130-bd4b-7cd1c3f718ad" style="display: block;"></a></p>
<p>Once upon a time, I took a course in high school called “Geometry.”  Perhaps you did too.   You learned about shapes in one dimension, two dimensions, and maybe even three.  What is the circumference of a circle?  The area of a rectangle?   The distance between a point and a line?   Come to think of it, we’ve been studying geometry all along in this book, using vectors to describe the motion of bodies in Cartesian space.  This sort of geometry is generally referred to as Euclidean geometry, after the Greek mathematician Euclid.</p>
<a id="chapter08_figure1" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_01.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.1</p>
</div>
<p>For us nature coders, we have to ask the question: Can we describe our world with Euclidean geometry?    The LCD screen I’m staring at right now sure looks like a rectangle.  And the plum I ate this morning is circular.  But what if I were to look further, and consider the trees that line the street, the leaves that hang off those trees, the lightning from last night’s thunderstorm, the cauliflower I ate for dinner, the blood vessels in my body, and the mountains and coastlines that cover land beyond New York City?   Most of the stuff you find in nature cannot be described by the idealized geometrical forms of Euclidean geometry.  So if we want to start building computational designs with patterns beyond the simple shapes <span class="function">ellipse()</span>, <span class="function">rect()</span>, and <span class="function">line()</span>, it’s time for us to learn about the concepts behind and techniques for simulating the geometry of nature: fractals.</p>
<section><a id="chapter08_section1" style="display: block;"></a><h3 id="81-what-is-a-fractal">8.1  What Is a Fractal?</h3><p><a id="fractalsdefined-82d67b90-253f-0130-bd4c-7cd1c3f718ad" style="display: block;"></a><a id="mandelbrot-benoit-82d69e80-253f-0130-bd4d-7cd1c3f718ad" style="display: block;"></a><a id="fractal-geometry-of-nature-the-mandelbrot-82da19a0-253f-0130-bd4e-7cd1c3f718ad" style="display: block;"></a></p>
<p>The term <strong><em>fractal</em></strong> (from the Latin <em>fractus</em>, meaning “broken”) was coined by the mathematician Benoit Mandelbrot in 1975.  In his seminal work “The Fractal Geometry of Nature,” he defines a fractal as “a rough or fragmented geometric shape that can be split into parts, each of which is (at least approximately) a reduced-size copy of the whole.”</p>
<a id="chapter08_figure2" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_02.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.2: One of the most well-known and recognizable fractal patterns is named for Benoit Mandelbrot himself.   Generating the Mandelbrot set involves testing the properties of complex numbers after they are passed through an iterative function.  Do they tend to infinity?  Do they stay bounded?  While a fascinating mathematical discussion, this “escape-time” algorithm is a less practical method for generating fractals than the recursive techniques we’ll examine in this chapter.  However, an example for generating the Mandelbrot set is included in the code examples.</p>
</div>
<p>Let’s illustrate this definition with two simple examples.  First, let’s think about a tree branching structure (for which we’ll write the code later):</p>
<a id="chapter08_figure3" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_03.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.3</p>
</div>
<p>Notice how the tree in Figure 8.3 has a single root with two branches connected at its end.  Each one of those branches has two branches at its end and those branches have two branches and so on and so forth.  What if we were to pluck one branch from the tree and examine it on its own?</p>
<a id="chapter08_figure4" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_04.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.4</p>
</div>
<p><a id="fractalsself-replicating-behavior-of-82da63c0-253f-0130-bd4f-7cd1c3f718ad" style="display: block;"></a><a id="self-similarity-of-fractals-82da76e0-253f-0130-bd50-7cd1c3f718ad" style="display: block;"></a></p>
<p>Looking closely at a given section of the tree, we find that the shape of this branch resembles the tree itself.   This is known as <strong><em>self-similarity</em></strong>; as Mandelbrot stated, each part is a “reduced-size copy of the whole.”</p>
<p>The above tree is perfectly symmetrical and the parts are, in fact, exact replicas of the whole.  However, fractals do not have to be perfectly self-similar.  Let’s take a look at a graph of the stock market (adapted from actual Apple stock data).</p>
<a id="chapter08_figure5" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_05.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.5: Graph A</p>
</div>
<p>And one more.</p>
<a id="chapter08_figure6" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_06.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.6: Graph B</p>
</div>
<p><a id="fractalsstochastic-82daac20-253f-0130-bd51-7cd1c3f718ad" style="display: block;"></a><a id="stochastic-fractals-82dabdf0-253f-0130-bd52-7cd1c3f718ad" style="display: block;"></a></p>
<p>In these graphs, the x-axis is time and the y-axis is the stock’s value.   It’s not an accident that I omitted the labels, however.   Graphs of stock market data are examples of fractals because they look the same at any scale.  Are these graphs of the stock over one year?  One day?  One hour?  There’s no way for you to know without a label.  (Incidentally, graph A shows six months’ worth of data and graph B zooms into a tiny part of graph A, showing six hours.)</p>
<a id="chapter08_figure7" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_07.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.7</p>
</div>
<p>This is an example of a <strong><em>stochastic</em></strong> fractal, meaning that it is built out of probabilities and randomness.  Unlike the deterministic tree-branching structure, it is statistically self-similar.  As we go through the examples in this chapter, we will look at both deterministic and stochastic techniques for generating fractal patterns.</p>
<p><a id="euclidean-geometryfractals-and-82daed10-253f-0130-bd53-7cd1c3f718ad" style="display: block;"></a><a id="fractalsfine-structure-of-82db07d0-253f-0130-bd54-7cd1c3f718ad" style="display: block;"></a></p>
<p>While self-similarity is a key trait of fractals, it’s important to realize that self-similarity alone does not make a fractal.  After all, a line is self-similar.  A line looks the same at any scale, and can be thought of as comprising lots of little lines.  But it’s not a fractal.  Fractals are  characterized by having a fine structure at small scales (keep zooming into the stock market graph and you’ll continue to find fluctuations) and cannot be described with Euclidean geometry.  If you can say “It’s a line!” then it’s not a fractal.</p>
<p><a id="fractalsrecursion-82db2250-253f-0130-bd55-7cd1c3f718ad" style="display: block;"></a><a id="recursion-82db3520-253f-0130-bd56-7cd1c3f718ad" style="display: block;"></a></p>
<p>Another fundamental component of fractal geometry is recursion.  Fractals all have a recursive definition.  We’ll start with recursion before developing techniques and code examples for building fractal patterns in Processing.</p>
</section><section><a id="chapter08_section2" style="display: block;"></a><h3 id="82-recursion">8.2 Recursion</h3><p><a id="cantor-set-82db5e70-253f-0130-bd57-7cd1c3f718ad" style="display: block;"></a><a id="cantor-george-82db7770-253f-0130-bd58-7cd1c3f718ad" style="display: block;"></a></p>
<p>Let’s begin our discussion of recursion by examining the first appearance of fractals in modern mathematics.  In 1883, German mathematician George Cantor developed simple rules to generate an infinite set:</p>
<a id="chapter08_figure8" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_08.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.8: The Cantor set</p>
</div>
<p>There is a feedback loop at work here.  Take a single line and break it into two.  Then return to those two lines and apply the same rule, breaking each line into two, and now we’re left with four.  Then return to those four lines and apply the rule.  Now you’ve got eight.   This process is known as <strong><em>recursion</em></strong>: the repeated application of a rule to successive results.   Cantor was interested in what happens when you apply these rules an infinite number of times.   We, however, are working in a finite pixel space and can mostly ignore the questions and paradoxes that arise from infinite recursion.  We will instead construct our code in such a way that we do not apply the rules forever (which would cause our program to freeze).</p>
<p><a id="recursionimplementing-82dbbbb0-253f-0130-bd59-7cd1c3f718ad" style="display: block;"></a></p>
<p>Before we implement the Cantor set, let’s take a look at what it means to have recursion in code.
Here’s something we’re used to doing all the time—calling a function inside another function.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void someFunction() {
  // Calling the function background()
  // in the definition of someFunction()
  background(0);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">someFunction</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Calling the function background()
in the definition of someFunction()</div><code><pre><span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>What would happen if we called the function we are defining within the function itself?   Can <span class="function">someFunction()</span> call <span class="function">someFunction()</span>?</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void someFunction() {
  someFunction();
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">someFunction</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">someFunction</span><span class="o">();</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p><a id="factorial-82dc0a30-253f-0130-bd5a-7cd1c3f718ad" style="display: block;"></a><a id="recursionfactorial-82dc1ae0-253f-0130-bd5b-7cd1c3f718ad" style="display: block;"></a></p>
<p>In fact, this is not only allowed, but it’s quite common (and essential to how we will implement the Cantor set).   Functions that call themselves are <em>recursive</em> and good for solving certain problems.  For example, certain mathematical calculations are implemented recursively; the most common example is <em>factorial</em>.</p>
<p>The factorial of any number n, usually written as n!, is defined as:</p>
<p><span class="formula">n! = n * n – 1 * . . . . * 3 * 2 * 1</span><br /><span class="formula">0! = 1</span></p>
<p>Here we’ll write a function in Processing that uses a <span class="function">for</span> loop to calculate factorial:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>int factorial(int n) {
  int f = 1;
  //[full] Using a regular loop to compute factorial
  for (int i = 0; i < n; i++) {
    f = f * (i+1);
  }
  //[end]
  return f;
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="kt">int</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Using a regular loop to compute factorial</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="o">*</span> <span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="k">return</span> <span class="n">f</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Upon close examination, you’ll notice something interesting about how factorial works. Let’s look at 4! and 3!</p>
<p><span class="formula">4! = 4 * 3 * 2 * 1</span><br /><span class="formula">3! = 3 * 2 * 1</span></p>
<p><strong><em>therefore. . .</em></strong></p>
<p><span class="formula">4! = 4 * 3!</span></p>
<p>In more general terms, for any positive integer n:</p>
<p><span class="formula">n! = n * (n-1)!</span><br /><span class="formula">1! = 1</span></p>
<p>Written out:</p>
<p>The <em>factorial</em> of <span class="var">n</span> is defined as <span class="var">n</span> times the <em>factorial</em> of <span class="var">n-1</span>.</p>
<p>The definition of <strong><em>factorial</em></strong> includes <strong><em>factorial</em></strong>?!  It’s kind of like defining “tired" as “the feeling you get when you are tired.”   This concept of self-reference in functions is an example of recursion.   And we can use it to write a factorial function that calls itself.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>int factorial(int n) {
  if (n == 1) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">int</span> <span class="nf">factorial</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>It may look crazy, but it works.   Here are the steps that happen when <span class="function">factorial(4)</span> is called.</p>
<a id="chapter08_figure9" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_09.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.9</p>
</div>
<p>We can apply the same principle to graphics with interesting results, as we will see in many examples throughout this chapter. Take a look at this recursive function.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_01_Recursion/_8_01_Recursion.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example1" style="display: block;"></a><span class="example">Example 8.1: Recursive Circles I</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void drawCircle(int x, int y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius > 2) {
    radius *= 0.75f;
    // The drawCircle() function is
    // calling itself recursively.
    drawCircle(x, y, radius);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">drawCircle</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">ellipse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">,</span> <span class="n">radius</span><span class="o">);</span></span>
<span class='one-line'>  <span class="k">if</span><span class="o">(</span><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">radius</span> <span class="o">*=</span> <span class="mf">0.75f</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The drawCircle() function is
calling itself recursively.</div><code><pre><span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p><span class="function">drawCircle()</span> draws an ellipse based on a set of parameters that it receives as arguments. It then calls itself with those same parameters, adjusting them slightly. The result is a series of circles, each of which is drawn inside the previous circle.</p>
<p><a id="exit-conditions-for-recursion-82dd1520-253f-0130-bd5c-7cd1c3f718ad" style="display: block;"></a><a id="recursionexit-conditions-82dd27d0-253f-0130-bd5d-7cd1c3f718ad" style="display: block;"></a></p>
<p>Notice that the above function only recursively calls itself if the radius is greater than 2.  This is a crucial point.  As with iteration, <em>all recursive functions must have an exit condition!</em>    You likely are already aware that all <span class="function">for</span> and <span class="function">while</span> loops must include a boolean expression that eventually evaluates to false, thus exiting the loop. Without one, the program would crash, caught inside of an infinite loop. The same can be said about recursion.  If a recursive function calls itself forever and ever, you’ll be most likely be treated to a nice frozen screen.</p>
<p>This circles example is rather trivial; it could easily be achieved through simple iteration. However, for scenarios in which a function calls itself more than once, recursion becomes wonderfully elegant.</p>
<p>Let’s make <span class="function">drawCircle()</span> a bit more complex.    For every circle displayed, draw a circle half its size to the left and right of that circle.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_02_Recursion/_8_02_Recursion.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example2" style="display: block;"></a><span class="example">Example 8.2: Recursion twice</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void setup() {
  size(640,360);
}

void draw() {
  background(255);
  drawCircle(width/2,height/2,200);
}

void drawCircle(float x, float y, float radius) {
  stroke(0);
  noFill();
  ellipse(x, y, radius, radius);
  if(radius > 2) {
    //[full] drawCircle() calls itself twice, creating
    // a branching effect.  For every circle,
    // a smaller circle is drawn to the left and the right.
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);

    //[end]
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">640</span><span class="o">,</span><span class="mi">360</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">drawCircle</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="mi">200</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">drawCircle</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">noFill</span><span class="o">();</span></span>
<span class='one-line'>  <span class="n">ellipse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">,</span> <span class="n">radius</span><span class="o">);</span></span>
<span class='one-line'>  <span class="k">if</span><span class="o">(</span><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> drawCircle() calls itself twice, creating
a branching effect.  For every circle,
a smaller circle is drawn to the left and the right.</div><code><pre><span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>With just a little more code, we could also add a circle above and below each circle.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_03_Recursion/_8_03_Recursion.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example3" style="display: block;"></a><span class="example">Example 8.3: Recursion four times</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void drawCircle(float x, float y, float radius) {
  ellipse(x, y, radius, radius);
  if(radius > 8) {
    drawCircle(x + radius/2, y, radius/2);
    drawCircle(x - radius/2, y, radius/2);
    drawCircle(x, y + radius/2, radius/2);
    drawCircle(x, y - radius/2, radius/2);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">drawCircle</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">radius</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">ellipse</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">,</span> <span class="n">radius</span><span class="o">);</span></span>
<span class='one-line'>  <span class="k">if</span><span class="o">(</span><span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">drawCircle</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">radius</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Try reproducing this sketch with iteration instead of recursion—I dare you!</p>
</section><section><a id="chapter08_section3" style="display: block;"></a><h3 id="83-the-cantor-set-with-a-recursive-function">8.3  The Cantor Set with a Recursive Function</h3><p><a id="cantor-setrecursion-and-82ddc340-253f-0130-bd5e-7cd1c3f718ad" style="display: block;"></a></p>
<p>Now we’re ready to visualize the Cantor set in Processing using a recursive function.  Where do we begin?  Well, we know that the Cantor set begins with a line.  So let’s start there and write a function that draws a line.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void cantor(float x, float y, float len) {
  line(x,y,x+len,y);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">cantor</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The above <span class="function">cantor()</span> function draws a line that starts at pixel coordinate <em>(x,y)</em> with a length of <span class="var">len</span>.  (The line is drawn horizontally here, but this is an arbitrary decision.)  So if we called that function, saying:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>cantor(10, 20, width-20);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">cantor</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="n">width</span><span class="o">-</span><span class="mi">20</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>we’d get the following:</p>
<a id="chapter08_figure10" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_10.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.10</p>
</div>
<a id="chapter08_figure11" style="display: block;"></a><div class="image-container half-width-right" >
	
	<img src="/book/imgs/chapter08/ch08_11.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.11</p>
</div>
<p>Now, the Cantor rule tells us to erase the middle third of that line, which leaves us with two lines, one from the beginning of the line to the one-third mark, and one from the two-thirds mark to the end of the line.</p>
<p>We can now add two more lines of code to draw the second pair of lines, moving the y-location down a bunch of pixels so that we can see the result below the original line.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;
  // From start to 1/3rd
  line(x,y,x+len/3,y); //[bold]
  // From 2/3rd to end
  line(x+len*2/3,y,x+len,y); //[bold]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">cantor</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>From start to 1/3rd</div><code><pre><span class='one-line'>  <strong><span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></strong></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>From 2/3rd to end</div><code><pre><span class='one-line'>  <strong><span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></strong></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><a id="chapter08_figure12" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_12.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.12</p>
</div>
<p>While this is a fine start, such a manual approach of calling <span class="function">line()</span> for each line is not what we want.   It will get unwieldy very quickly, as we’d need four, then eight, then sixteen calls to <span class="function">line()</span>.  Yes, a <span class="function">for</span> loop is our usual way around such a problem, but give that a try and you’ll see that working out the math for each iteration quickly proves inordinately complicated.   Here is where recursion comes and rescues us.</p>
<p>Take a look at where we draw that first line from the start to the one-third mark.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>   line(x,y,x+len/3,y);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>   <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Instead of calling the <span class="function">line()</span> function directly, we can simply call the <span class="function">cantor()</span> function itself.  After all, what does the <span class="function">cantor()</span> function do?  It draws a line at an <em>(x,y)</em> location with a given length!  And so:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>   line(x,y,x+len/3,y);         becomes ------->  cantor(x,y,len/3);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>   <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>         <span class="n">becomes</span> <span class="o">-------&gt;</span>  <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>And for the second line:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>   line(x+len*2/3,y,x+len,y);   becomes ------->  cantor(x+len*2/3,y,len/3);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>   <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span>   <span class="n">becomes</span> <span class="o">-------&gt;</span>  <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Leaving us with:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void cantor(float x, float y, float len) {
  line(x,y,x+len,y);

  y += 20;

  cantor(x,y,len/3);
  cantor(x+len*2/3,y,len/3);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">cantor</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>And since the <span class="function">cantor()</span> function is called recursively, the same rule will be applied to the next lines and to the next and to the next as <span class="function">cantor()</span> calls itself again and again!  Now, don’t go and run this code yet.  We’re missing that crucial element: an exit condition.   We’ll want to make sure we stop at some point—for example, if the length of the line ever is less than 1 pixel.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_04_CantorSet/_8_04_CantorSet.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example4" style="display: block;"></a><span class="example">Example 8.4: Cantor set</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void cantor(float x, float y, float len) {
  // Stop at 1 pixel!
  if (len >= 1) {
    line(x,y,x+len,y);
    y += 20;
    cantor(x,y,len/3);
    cantor(x+len*2/3,y,len/3);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">cantor</span><span class="o">(</span><span class="kt">float</span> <span class="n">x</span><span class="o">,</span> <span class="kt">float</span> <span class="n">y</span><span class="o">,</span> <span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Stop at 1 pixel!</div><code><pre><span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">line</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">,</span><span class="n">y</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">y</span> <span class="o">+=</span> <span class="mi">20</span><span class="o">;</span></span>
<span class='one-line'>    <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">cantor</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">len</span><span class="o">*</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="o">,</span><span class="n">y</span><span class="o">,</span><span class="n">len</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <h4 id="exercise-81">Exercise 8.1</h4><p>Using <span class="function">drawCircle()</span> and the Cantor set as models, generate your own pattern with recursion.  Here is a screenshot of one that uses lines.</p>
<div class="image-container screenshot" >
	
	<img src="/book/imgs/chapter08/ch08_exc01.png" alt="Nature of Code Image" />
	
	
</div>

</div></section><section><a id="chapter08_section4" style="display: block;"></a><h3 id="84-the-koch-curve-and-the-arraylist-technique">8.4  The Koch Curve and the ArrayList Technique</h3><p><a id="arraylist-class-javafractals-and-82e1f410-253f-0130-bd5f-7cd1c3f718ad" style="display: block;"></a><a id="fractalskoch-curve-82e20d60-253f-0130-bd60-7cd1c3f718ad" style="display: block;"></a><a id="koch-curve-82e223e0-253f-0130-bd61-7cd1c3f718ad" style="display: block;"></a><a id="recursionarraylist-objects-and-82e23a70-253f-0130-bd62-7cd1c3f718ad" style="display: block;"></a></p>
<p>Writing a function that recursively calls itself is one technique for generating a fractal pattern on screen.  However, what if you wanted the lines in the above Cantor set to exist as individual objects that could be moved independently?   The recursive function is simple and elegant, but it does not allow you to do much besides simply generating the pattern itself.  However, there is another way we can apply recursion in combination with an <span class="klass">ArrayList</span> that will allow us to not only generate a fractal pattern, but keep track of all its individual parts as objects.</p>
<p>To demonstrate this technique, let’s look at another famous fractal pattern, discovered in 1904 by Swedish mathematician Helge von Koch.   Here are the rules.  (Note that it starts the same way as the Cantor set, with a single line.)</p>
<a id="chapter08_figure13" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_13.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.13</p>
</div>
<p>The result looks like:</p>
<a id="chapter08_figure14" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_14.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.14</p>
</div>
<p><a id="monster-curve-82e27810-253f-0130-bd63-7cd1c3f718ad" style="display: block;"></a></p>
<div class="note">
  <h4 id="the-monster-curve">The “Monster” Curve</h4><p>The Koch curve and other fractal patterns are often called “mathematical monsters.”   This is due to an odd paradox that emerges when you apply the recursive definition an infinite number of times.  If the length of the original starting line is one, the first iteration of the Koch curve will yield a line of length four-thirds (each segment is one-third the length of the starting line).  Do it again and you get a length of sixteen-ninths.  As you iterate towards infinity, the length of the Koch curve approaches infinity.  Yet it fits in the tiny finite space provided right here on this paper (or screen)!</p>
<p>Since we are working in the Processing land of finite pixels, this theoretical paradox won’t be a factor for us.  We’ll have to limit the number of times we recursively apply the Koch rules so that our program won’t run out of memory or crash.</p>

</div><p>We could proceed in the same manner as we did with the Cantor set, and write a recursive function that iteratively applies the Koch rules over and over.   Nevertheless, we are going to tackle this problem in a different manner by treating each segment of the Koch curve as an individual object.  This will open up some design possibilities.  For example, if each segment is an object, we could allow each segment to move independently from its original location and participate in a physics simulation.  In addition, we could use a random color, line thickness, etc. to display each segment differently.</p>
<p>In order to accomplish our goal of treating each segment as an individual object, we must first decide what this object should be in the first place.  What data should it store?  What functions should it have?</p>
<p>The Koch curve is a series of connected lines, and so we will think of each segment as a “KochLine.”  Each <span class="klass">KochLine</span> object has a start point (“a”) and an end point (“b”).  These points are <span class="klass">PVector</span> objects, and the line is drawn with Processing’s <span class="function">line()</span> function.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>class KochLine {

  //[full] A line between two points: start and end
  PVector start;
  PVector end;
  //[end]

  KochLine(PVector a, PVector b) {
    start = a.get();
    end = b.get();
  }

  void display() {
    stroke(0);
    // Draw the line from PVector start to end.
    line(start.x, start.y, end.x, end.y);
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kd">class</span> <span class="nc">KochLine</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> A line between two points: start and end</div><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">start</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">end</span><span class="o">;</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'>  <span class="n">KochLine</span><span class="o">(</span><span class="n">PVector</span> <span class="n">a</span><span class="o">,</span> <span class="n">PVector</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">start</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">end</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="kt">void</span> <span class="nf">display</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Draw the line from PVector start to end.</div><code><pre><span class='one-line'>    <span class="n">line</span><span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">start</span><span class="o">.</span><span class="na">y</span><span class="o">,</span> <span class="n">end</span><span class="o">.</span><span class="na">x</span><span class="o">,</span> <span class="n">end</span><span class="o">.</span><span class="na">y</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now that we have our <span class="klass">KochLine</span> class, we can get started on the main program.  We’ll need a data structure to keep track of what will eventually become many <span class="klass">KochLine</span> objects, and an <span class="klass">ArrayList</span> (see Chapter 4 for a review of <span class="klass">ArrayList</span>s) will do just fine.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>ArrayList<KochLine> lines;</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;</span> <span class="n">lines</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>In <span class="function">setup()</span>, we’ll want to create the <span class="klass">ArrayList</span> and add the first line segment to it, a line that stretches from 0 to the width of the sketch.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void setup() {
  size(600, 300);
  // Create the ArrayList.
  lines = new ArrayList<KochLine>();

  // Left side of window
  PVector start = new PVector(0, 200);
  // Right side of window
  PVector end   = new PVector(width, 200);

  // The first KochLine object
  lines.add(new KochLine(start, end));
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">600</span><span class="o">,</span> <span class="mi">300</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Create the ArrayList.</div><code><pre><span class='one-line'>  <span class="n">lines</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;();</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Left side of window</div><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Right side of window</div><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="n">end</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The first KochLine object</div><code><pre><span class='one-line'>  <span class="n">lines</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">));</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Then in <span class="function">draw()</span>, all <span class="klass">KochLine</span> objects (just one right now) can be displayed in a loop.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void draw() {
  background(255);
  for (KochLine l : lines) {
    l.display();
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span>
<span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="n">KochLine</span> <span class="n">l</span> <span class="o">:</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">l</span><span class="o">.</span><span class="na">display</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>This is our foundation.  Let’s review what we have so far:</p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>KochLine class:</em></strong> A class to keep track of a line from point A to B.
</p>
</li>
		
			<li><p><strong><em>ArrayList:</em></strong> A list of all <span class="klass">KochLine</span> objects.
</p>
</li>
		
	</ul>
</div><p>With the above elements, how and where do we apply Koch rules and principles of recursion?</p>
<p><a id="koch-curveimplementing-82e335a0-253f-0130-bd64-7cd1c3f718ad" style="display: block;"></a></p>
<p>Remember the Game of Life cellular automata?  In that simulation, we always kept track of two generations: current and next.  When we were finished computing the next generation, next became current and we moved on to computing the new next generation.
 We are going to apply a similar technique here.  We have an <span class="klass">ArrayList</span> that keeps track of the current set of <span class="klass">KochLine</span> objects (at the start of the program, there is only one).  We will need a second <span class="klass">ArrayList</span> (let’s call it “next”) where we will place all the new <span class="klass">KochLine</span> objects that are generated from applying the Koch rules.   For every <span class="klass">KochLine</span> object in the current <span class="klass">ArrayList</span>, four new <span class="klass">KochLine</span> objects are added to the next <span class="klass">ArrayList</span>.  When we’re done, the next <span class="klass">ArrayList</span> becomes the current one.</p>
<a id="chapter08_figure15" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_15.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.15</p>
</div>
<p>Here’s how the code will look:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void generate() {
  // Create the next ArrayList...
  ArrayList next = new ArrayList<KochLine>();

  // ...for every current line.
  for (KochLine l : lines) {

    //[full] Add four new lines. (We need to figure out how
    // to compute the locations of these lines!)
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    next.add(new KochLine(???,???));
    //[end]
  }
  // The new ArrayList is now the
  // one we care about!
  lines = next;
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">generate</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Create the next ArrayList...</div><code><pre><span class='one-line'>  <span class="n">ArrayList</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;();</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>...for every current line.</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="n">KochLine</span> <span class="n">l</span> <span class="o">:</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Add four new lines. (We need to figure out how
to compute the locations of these lines!)</div><code><pre><span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(???,???));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(???,???));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(???,???));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(???,???));</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="o">}</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The new ArrayList is now the
one we care about!</div><code><pre><span class='one-line'>  <span class="n">lines</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>By calling <span class="function">generate()</span> over and over again (for example, each time the mouse is pressed), we recursively apply the Koch curve rules to the existing set of <span class="klass">KochLine</span> objects.
 Of course, the above omits the real “work” here, which is figuring out those rules.  How do we break one line segment into four as described by the rules?   While this can be accomplished with some simple arithmetic and trigonometry, since our <span class="klass">KochLine</span> object uses <span class="klass">PVector</span>, this is a nice opportunity for us to practice our vector math.  Let’s establish how many points we need to compute for each <span class="klass">KochLine</span> object.</p>
<a id="chapter08_figure16" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_16.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.16</p>
</div>
<p>As you can see from the above figure, we need five points  (a, b, c, d, and e) to generate the new <span class="klass">KochLine</span> objects and make the new line segments (ab, cb, cd, and de).</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>    next.add(new KochLine(a,b));
    next.add(new KochLine(b,c));
    next.add(new KochLine(c,d));
    next.add(new KochLine(d,e));</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">a</span><span class="o">,</span><span class="n">b</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">b</span><span class="o">,</span><span class="n">c</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">c</span><span class="o">,</span><span class="n">d</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">d</span><span class="o">,</span><span class="n">e</span><span class="o">));</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Where do we get these points?  Since we have a <span class="klass">KochLine</span> object, why not ask the <span class="klass">KochLine</span> object to compute all these points for us?</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void generate() {
  ArrayList next = new ArrayList<KochLine>();
  for (KochLine l : lines) {

    //[full] The KochLine object has five functions,
    // each of which return a PVector according
    // to the Koch rules.
    PVector a = l.kochA();
    PVector b = l.kochB();
    PVector c = l.kochC();
    PVector d = l.kochD();
    PVector e = l.kochE();
    //[end]

    next.add(new KochLine(a, b));
    next.add(new KochLine(b, c));
    next.add(new KochLine(c, d));
    next.add(new KochLine(d, e));
  }

  lines = next;
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">generate</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">ArrayList</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;();</span></span>
<span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="n">KochLine</span> <span class="n">l</span> <span class="o">:</span> <span class="n">lines</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> The KochLine object has five functions,
each of which return a PVector according
to the Koch rules.</div><code><pre><span class='one-line'>    <span class="n">PVector</span> <span class="n">a</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">kochA</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">b</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">kochB</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">c</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">kochC</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">d</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">kochD</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">e</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="na">kochE</span><span class="o">();</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'> </span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">));</span></span>
<span class='one-line'>    <span class="n">next</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">d</span><span class="o">,</span> <span class="n">e</span><span class="o">));</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">lines</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now we just need to write five new functions in the <span class="klass">KochLine</span> class, each one returning a <span class="klass">PVector</span> according to <a href="#chapter08_figure16">Figure 8.16</a> above.  Let’s knock off <span class="function">kochA()</span> and <span class="function">kochE()</span> first, which are simply the start and end points of the original line.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  PVector kochA() {
    // Note the use of get(), which returns a copy of the PVector. As was noted in
    // Chapter 6, section 14, we want to avoid making copies whenever
    // possible, but here we will need a new PVector in case we want the segments to move
    // independently of each other.
    return start.get();
  }

  PVector kochE() {
    return end.get();
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="nf">kochA</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Note the use of get(), which returns a copy of the PVector. As was noted in
Chapter 6, section 14, we want to avoid making copies whenever
possible, but here we will need a new PVector in case we want the segments to move
independently of each other.</div><code><pre><span class='one-line'>    <span class="k">return</span> <span class="n">start</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">PVector</span> <span class="nf">kochE</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="n">end</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now let’s move on to points B and D.  B is one-third of the way along the line segment and D is two-thirds.  Here we can make a <span class="klass">PVector</span> that points from start to end and shrink it to one-third the length for B and two-thirds the length for D to find these points.</p>
<a id="chapter08_figure17" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_17.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.17</p>
</div>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  PVector kochB() {
    // PVector from start to end
    PVector v = PVector.sub(end, start);
    // One-third the length
    v.div(3);
    // Add that PVector to the beginning of the line
    // to find the new point.
    v.add(start);
    return v;
  }

  PVector kochD() {
    PVector v = PVector.sub(end, start);
    // Same thing here, only we need to move two-thirds
    // along the line instead of one-third.
    v.mult(2/3.0);
    v.add(start);
    return v;
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="nf">kochB</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>PVector from start to end</div><code><pre><span class='one-line'>    <span class="n">PVector</span> <span class="n">v</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>One-third the length</div><code><pre><span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">div</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Add that PVector to the beginning of the line
to find the new point.</div><code><pre><span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="n">v</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">PVector</span> <span class="nf">kochD</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">v</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Same thing here, only we need to move two-thirds
along the line instead of one-third.</div><code><pre><span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">mult</span><span class="o">(</span><span class="mi">2</span><span class="o">/</span><span class="mf">3.0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">return</span> <span class="n">v</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The last point, C, is the most difficult one to find.  However, if you recall that the angles of an equilateral triangle are all sixty degrees, this makes it a little bit easier.  If we know how to find point B with a <span class="klass">PVector</span> one-third the length of the line, what if we were to rotate that same <span class="klass">PVector</span> sixty degrees and move along that vector from point B?  We’d be at point C!</p>
<a id="chapter08_figure18" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_18.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.18</p>
</div>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  PVector kochC() {
    // Start at the beginning.
    PVector a = start.get();

    PVector v = PVector.sub(end, start);
    // Move 1/3rd of the way to point B.
    v.div(3);
    a.add(v);

    // Rotate “above” the line 60 degrees.
    v.rotate(-radians(60));
    // Move along that vector to point C.
    a.add(v);

    return a;
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'>  <span class="n">PVector</span> <span class="nf">kochC</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Start at the beginning.</div><code><pre><span class='one-line'>    <span class="n">PVector</span> <span class="n">a</span> <span class="o">=</span> <span class="n">start</span><span class="o">.</span><span class="na">get</span><span class="o">();</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="n">PVector</span> <span class="n">v</span> <span class="o">=</span> <span class="n">PVector</span><span class="o">.</span><span class="na">sub</span><span class="o">(</span><span class="n">end</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Move 1/3rd of the way to point B.</div><code><pre><span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">div</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Rotate “above” the line 60 degrees.</div><code><pre><span class='one-line'>    <span class="n">v</span><span class="o">.</span><span class="na">rotate</span><span class="o">(-</span><span class="n">radians</span><span class="o">(</span><span class="mi">60</span><span class="o">));</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Move along that vector to point C.</div><code><pre><span class='one-line'>    <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="k">return</span> <span class="n">a</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Putting it all together, if we call <span class="function">generate()</span> five times in <span class="function">setup()</span>, we’ll see the following result.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_05_Koch/_8_05_Koch.pde /book/processingjs/chapter08/_8_05_Koch/KochFractal.pde /book/processingjs/chapter08/_8_05_Koch/Kochline.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example5" style="display: block;"></a><span class="example">Example 8.5: Koch curve</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>ArrayList<KochLine> lines;

void setup() {
  size(600, 300);
  background(255);
  lines = new ArrayList<KochLine>();
  PVector start = new PVector(0, 200);
  PVector end   = new PVector(width, 200);
  lines.add(new KochLine(start, end));

  // Arbitrarily apply the Koch rules five times.
  for (int i = 0; i < 5; i++) {
    generate();
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;</span> <span class="n">lines</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">600</span><span class="o">,</span> <span class="mi">300</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">lines</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">KochLine</span><span class="o">&gt;();</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">start</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">PVector</span> <span class="n">end</span>   <span class="o">=</span> <span class="k">new</span> <span class="n">PVector</span><span class="o">(</span><span class="n">width</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">lines</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">KochLine</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">));</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Arbitrarily apply the Koch rules five times.</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">generate</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <h4 id="exercise-82">Exercise 8.2</h4><div class="image-container half-width-right" >
	
	<img src="/book/imgs/chapter08/ch08_exc02.png" alt="Nature of Code Image" />
	
	
</div>
<p>Draw the Koch snowflake (or some other variation of the Koch curve).</p>
<div class="image-container " >
	
	<img src="/book/imgs/blank.png" alt="Nature of Code Image" />
	
	
</div>

</div><div class="example">
  <h4 id="exercise-83">Exercise 8.3</h4><p>Try animating the Koch curve.  For example, can you draw it from left to right?  Can you vary the visual design of the line segments?  Can you move the line segments using techniques from earlier chapters?  What if each line segment were made into a spring (toxiclibs) or joint (Box2D)?</p>

</div><div class="example">
  <h4 id="exercise-84">Exercise 8.4</h4><p>Rewrite the Cantor set example using objects and an <span class="klass">ArrayList</span>.</p>

</div><div class="example">
  <h4 id="exercise-85">Exercise 8.5</h4><p>Draw the Sierpiński triangle (as seen in Wolfram elementary CA) using recursion.</p>
<div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_exc05.png" alt="Nature of Code Image" />
	
	
</div>

</div></section><section><a id="chapter08_section5" style="display: block;"></a><h3 id="85-trees">8.5  Trees</h3><p><a id="fractalstrees-and-82e79350-253f-0130-bd65-7cd1c3f718ad" style="display: block;"></a><a id="natural-fractals-82e7a590-253f-0130-bd66-7cd1c3f718ad" style="display: block;"></a><a id="natural-phenomenatrees-and-82e7b5a0-253f-0130-bd67-7cd1c3f718ad" style="display: block;"></a><a id="stochastic-fractalstrees-as-82e7d3f0-253f-0130-bd68-7cd1c3f718ad" style="display: block;"></a><a id="trees-82e7e8f0-253f-0130-bd69-7cd1c3f718ad" style="display: block;"></a></p>
<p>The fractals we have examined in this chapter so far are deterministic, meaning they have no randomness and will always produce the identical outcome each time they are run.   They are excellent demonstrations of classic fractals and the programming techniques behind drawing them, but are too precise to feel <em>natural</em>.  In this next part of the chapter, I want to examine some techniques behind generating a stochastic (or non-deterministic) fractal.   The example we’ll use is a branching tree.  Let’s first walk through the steps to create a deterministic version.  Here are our production rules:</p>
<a id="chapter08_figure19" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_19.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.19</p>
</div>
<p>Again, we have a nice fractal with a recursive definition: A branch is a line with two branches connected to it.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_06_Tree_static/_8_06_Tree_static.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="transformations-tutorial-processing-82e825f0-253f-0130-bd6a-7cd1c3f718ad" style="display: block;"></a><a id="fractalstransformation-matrix-processing-82e836b0-253f-0130-bd6b-7cd1c3f718ad" style="display: block;"></a><a id="popmatrix-function-processing-82e848c0-253f-0130-bd6c-7cd1c3f718ad" style="display: block;"></a><a id="pushmatrix-function-processing-82e85950-253f-0130-bd6d-7cd1c3f718ad" style="display: block;"></a><a id="transformation-matrix-processing-82e87190-253f-0130-bd6e-7cd1c3f718ad" style="display: block;"></a></p>
<p>The part that is a bit more difficult than our previous fractals lies in the use of the word <em>rotate</em> in the fractal’s rules.   Each new branch must rotate relative to the previous branch, which is rotated relative to all its previous branches.  Luckily for us, Processing has a mechanism to keep track of rotations for us—the <strong><em>transformation matrix</em></strong>.  If you aren’t familiar with the functions <span class="function">pushMatrix()</span> and <span class="function">popMatrix()</span>, I suggest you read the online Processing tutorial <a href="http://processing.org/learning/transform2d/">2D Transformations</a>, which will cover the concepts you’ll need for this particular example.</p>
<p>Let’s begin by drawing a single branch, the trunk of the tree.    Since we are going to involve the <span class="function">rotate()</span> function, we’ll need to make sure we are continuously translating along the branches while we draw the tree.  And since the root starts at the bottom of the window (see above), the first step requires translating to that spot:</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>translate(width/2,height);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">translate</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><a id="chapter08_figure20" style="display: block;"></a><div class="image-container half-width-right-border" >
	
	<img src="/book/imgs/chapter08/ch08_20.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.20</p>
</div>
<p>…followed by drawing a line upwards (Figure 8.20):</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>line(0,0,0,-100);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Once we’ve finished the root, we just need to translate to the end and rotate in order to draw the next branch.  (Eventually, we’re going to need to package up what we’re doing right now into a recursive function, but let’s sort out the steps first.)</p>
<a id="chapter08_figure21" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_21.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.21</p>
</div>
<p>Remember, when we rotate in Processing, we are always rotating around the point of origin, so here the point of origin must always be translated to the end of our current branch.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>translate(0,-100);
rotate(PI/6);
line(0,0,0,-100);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'><span class="n">rotate</span><span class="o">(</span><span class="n">PI</span><span class="o">/</span><span class="mi">6</span><span class="o">);</span></span>
<span class='one-line'><span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now that we have a branch going to the right, we need one going to the left.  We can use <span class="function">pushMatrix()</span> to save the transformation state before we rotate, letting us call <span class="function">popMatrix()</span> to restore that state and draw the branch to the left.  Let’s look at all the code together.</p>
<a id="chapter08_figure22" style="display: block;"></a><div class="image-container two-col" >
	
	<img src="/book/imgs/chapter08/ch08_22.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.22</p>
</div>
<a id="chapter08_figure23" style="display: block;"></a><div class="image-container two-col" >
	
	<img src="/book/imgs/chapter08/ch08_23.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.23</p>
</div>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>translate(width/2,height);
// The root
line(0,0,0,-100);
translate(0,-100);

pushMatrix();
rotate(PI/6);
// Branch to the right
line(0,0,0,-100);
popMatrix();

rotate(-PI/6);
// Branch to the left
line(0,0,0,-100);</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">translate</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The root</div><code><pre><span class='one-line'><span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'><span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'><span class="n">rotate</span><span class="o">(</span><span class="n">PI</span><span class="o">/</span><span class="mi">6</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Branch to the right</div><code><pre><span class='one-line'><span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'><span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="n">rotate</span><span class="o">(-</span><span class="n">PI</span><span class="o">/</span><span class="mi">6</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Branch to the left</div><code><pre><span class='one-line'><span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,-</span><span class="mi">100</span><span class="o">);</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>If you think of each call to the function <span class="function">line()</span> as a “branch,” you can see from the code above that we have implemented our definition of branching as a line that has two lines connected to its end.  We could keep adding more and more calls to <span class="function">line()</span> for more and more branches, but just as with the Cantor set and Koch curve, our code would become incredibly complicated and unwieldy.   Instead, we can use the above logic as our foundation for writing a recursive function, replacing the direct calls to <span class="function">line()</span> with our own function called <span class="function">branch()</span>.  Let’s take a look.</p>
<p><a id="chapter08_example6" style="display: block;"></a><span class="example">Example 8.6: Recursive tree</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void branch() {
  // Draw the branch itself.
  line(0, 0, 0, -100);
  // Translate to the end.
  translate(0, -100);

  pushMatrix();
  // Rotate to the right and branch again.
  rotate(PI/6);
  branch();
  popMatrix();

  pushMatrix();
  // Rotate to the left and branch again.
  rotate(-PI/6);
  branch();
  popMatrix();
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">branch</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Draw the branch itself.</div><code><pre><span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">100</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Translate to the end.</div><code><pre><span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">100</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">pushMatrix</span><span class="o">();</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Rotate to the right and branch again.</div><code><pre><span class='one-line'>  <span class="n">rotate</span><span class="o">(</span><span class="n">PI</span><span class="o">/</span><span class="mi">6</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">branch</span><span class="o">();</span></span>
<span class='one-line'>  <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">pushMatrix</span><span class="o">();</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Rotate to the left and branch again.</div><code><pre><span class='one-line'>  <span class="n">rotate</span><span class="o">(-</span><span class="n">PI</span><span class="o">/</span><span class="mi">6</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">branch</span><span class="o">();</span></span>
<span class='one-line'>  <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Notice how in the above code we use <span class="function">pushMatrix()</span> and <span class="function">popMatrix()</span> around each subsequent call to <span class="function">branch()</span>.   This is one of those elegant code solutions that feels almost like magic.  Each call to <span class="function">branch()</span> takes a moment to remember the location of that particular branch.    If you turn yourself into Processing for a moment and try to follow the recursive function with pencil and paper, you’ll notice that it draws all of the branches to the right first.   When it gets to the end, <span class="function">popMatrix()</span> will pop us back along all of the branches we’ve drawn and start sending branches out to the left.</p>
<div class="example">
  <h4 id="exercise-86">Exercise 8.6</h4><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_exc06.png" alt="Nature of Code Image" />
	
	
</div>
<p>Emulate the Processing code in <a href="#chapter08_example6">Example 8.6</a> and number the branches in the above diagram in the order that Processing would actually draw each one.</p>

</div><p>You may have noticed that the recursive function we just wrote would not actually draw the above tree.  After all, it has no exit condition and would get stuck in infinite recursive calls to itself.   You’ll also probably notice that the branches of the tree get shorter at each level.   Let’s look at how we can shrink the length of the lines as the tree is drawn, and stop branching once the lines have become too short.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// Each branch now receives
// its length as an argument.
void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  // Each branch’s length
  // shrinks by two-thirds.
  len *= 0.66;

  if (len > 2) {
    pushMatrix();
    rotate(theta);
    // Subsequent calls to branch()
    // include the length argument.
    branch(len);
    popMatrix();

    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>Each branch now receives
its length as an argument.</div><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">branch</span><span class="o">(</span><span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Each branch’s length
shrinks by two-thirds.</div><code><pre><span class='one-line'>  <span class="n">len</span> <span class="o">*=</span> <span class="mf">0.66</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(</span><span class="n">theta</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Subsequent calls to branch()
include the length argument.</div><code><pre><span class='one-line'>    <span class="n">branch</span><span class="o">(</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'> </span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(-</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">branch</span><span class="o">(</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>We’ve also included a variable for theta that allows us, when writing the rest of the code in <span class="function">setup()</span> and <span class="function">draw()</span>, to vary the branching angle according to, say, the <span class="var">mouseX</span> location.</p>
<div class="image-container three-col" >
	
	<img src="/book/imgs/chapter08/ch08_ex06a.png" alt="Nature of Code Image" />
	
	
</div>
<div class="image-container three-col" >
	
	<img src="/book/imgs/chapter08/ch08_ex06b.png" alt="Nature of Code Image" />
	
	
</div>
<div class="image-container three-col" >
	
	<img src="/book/imgs/chapter08/ch08_ex06c.png" alt="Nature of Code Image" />
	
	
</div>
<p><a id="chapter08_example7" style="display: block;"></a><span class="example">Example 8.7: Recursive tree</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>float theta;

void setup() {
  size(300, 200);
}

void draw() {
  background(255);
  // Pick an angle according to
  // the mouse location.
  theta = map(mouseX,0,width,0,PI/2);

  // The first branch starts at the
  // bottom of the window.
  translate(width/2, height);
  stroke(0);
  branch(60);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">float</span> <span class="n">theta</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">300</span><span class="o">,</span> <span class="mi">200</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Pick an angle according to
the mouse location.</div><code><pre><span class='one-line'>  <span class="n">theta</span> <span class="o">=</span> <span class="n">map</span><span class="o">(</span><span class="n">mouseX</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">width</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">PI</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The first branch starts at the
bottom of the window.</div><code><pre><span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">stroke</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">branch</span><span class="o">(</span><span class="mi">60</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <h4 id="exercise-87">Exercise 8.7</h4><p>Vary the <span class="function">strokeWeight()</span> for each branch.  Make the root thick and each subsequent branch thinner.</p>
<div class="image-container screenshot" >
	
	<img src="/book/imgs/chapter08/ch08_exc07.png" alt="Nature of Code Image" />
	
	
</div>

</div><div class="example">
  <h4 id="exercise-88">Exercise 8.8</h4><p>The tree structure can also be generated using the <span class="klass">ArrayList</span> technique demonstrated with the Koch curve.  Recreate the tree using a <span class="var">Branch</span> object and an <span class="klass">ArrayList</span> to keep track of the branches.  Hint: you’ll want to keep track of the branch directions and lengths using vector math instead of Processing transformations.</p>

</div><div class="example">
  <h4 id="exercise-89">Exercise 8.9</h4><p>Once you have the tree built with an <span class="klass">ArrayList</span> of <span class="var">Branch</span> objects, animate the tree’s growth.  Can you draw leaves at the end of the branches?</p>

</div><p>The recursive tree fractal is a nice example of a scenario in which adding a little bit of randomness can make the tree look more natural.  Take a look outside and you’ll notice that branch lengths and angles vary from branch to branch, not to mention the fact that branches don’t all have exactly the same number of smaller branches.   First, let’s see what happens when we simply vary the angle and length.  This is a pretty easy one, given that we can just ask Processing for a random number each time we draw the tree.</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_07_TreeStochastic_angleonly/_8_07_TreeStochastic_angleonly.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void branch(float len) {
  // Start by picking a random
  // angle for each branch.
  float theta = random(0,PI/3);

  line(0, 0, 0, -len);
  translate(0, -len);
  len *= 0.66;
  if (len > 2) {
    pushMatrix();
    rotate(theta);
    branch(len);
    popMatrix();
    pushMatrix();
    rotate(-theta);
    branch(len);
    popMatrix();
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">branch</span><span class="o">(</span><span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Start by picking a random
angle for each branch.</div><code><pre><span class='one-line'>  <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">random</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="n">PI</span><span class="o">/</span><span class="mi">3</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">len</span> <span class="o">*=</span> <span class="mf">0.66</span><span class="o">;</span></span>
<span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">branch</span><span class="o">(</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(-</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">branch</span><span class="o">(</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>In the above function, we always call <span class="function">branch()</span> twice.  But why not pick a random number of branches and call <span class="function">branch()</span> that number of times?</p>
<div class="image-container screenshot" >
	
	<canvas data-processing-sources="/book/processingjs/chapter08/_8_07_TreeStochastic/_8_07_TreeStochastic.pde" class="screenshot">
		<p>Your browser does not support the canvas tag.</p>
	</canvas>
  <div class="sketch-controls">
    <button class="reset">RESET</button>
    <button class="pause">PAUSE</button>
  </div>
	
	
</div>
<p><a id="chapter08_example8" style="display: block;"></a><span class="example">Example 8.8: Stochastic tree</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>void branch(float len) {

  line(0, 0, 0, -len);
  translate(0, -len);

  if (len > 2) {

    // Call branch() a random
    // number of times.
    int n = int(random(1,4));
    for (int i = 0; i < n; i++) {

      // Each branch gets its own random angle.
      float theta = random(-PI/2, PI/2);
      pushMatrix();
      rotate(theta);
      branch(h);
      popMatrix();
    }
  }</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="kt">void</span> <span class="nf">branch</span><span class="o">(</span><span class="kt">float</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="n">len</span><span class="o">);</span></span>
<span class='one-line'> </span>
<span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Call branch() a random
number of times.</div><code><pre><span class='one-line'>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="kt">int</span><span class="o">(</span><span class="n">random</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">));</span></span>
<span class='one-line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Each branch gets its own random angle.</div><code><pre><span class='one-line'>      <span class="kt">float</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">random</span><span class="o">(-</span><span class="n">PI</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span> <span class="n">PI</span><span class="o">/</span><span class="mi">2</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>      <span class="n">rotate</span><span class="o">(</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">branch</span><span class="o">(</span><span class="n">h</span><span class="o">);</span></span>
<span class='one-line'>      <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <h4 id="exercise-810">Exercise 8.10</h4><p>Set the angles of the branches of the tree according to Perlin noise values.  Adjust the noise values over time to animate the tree.  See if you can get it to appear as if it is blowing in the wind.</p>

</div><div class="example">
  <h4 id="exercise-811">Exercise 8.11</h4><p>Use toxiclibs to simulate tree physics.  Each branch of the tree should be two particles connected with a spring.  How can you get the tree to stand up and not fall down?</p>

</div></section><section><a id="chapter08_section6" style="display: block;"></a><h3 id="86-l-systems">8.6  L-systems</h3><p><a id="fractalsl-systems-and-82ea3f10-253f-0130-bd6f-7cd1c3f718ad" style="display: block;"></a><a id="l-systems-82ea5250-253f-0130-bd70-7cd1c3f718ad" style="display: block;"></a><a id="lindenmayer-systems-82ea61b0-253f-0130-bd71-7cd1c3f718ad" style="display: block;"></a><a id="lindenmayer-aristid-82ea71b0-253f-0130-bd72-7cd1c3f718ad" style="display: block;"></a><a id="natural-phenomenal-systems-and-82ea8220-253f-0130-bd73-7cd1c3f718ad" style="display: block;"></a></p>
<p>In 1968, Hungarian botanist Aristid Lindenmayer developed a grammar-based system to model the growth patterns of plants.    L-systems (short for Lindenmayer systems) can be used to generate all of the recursive fractal patterns we’ve seen so far in this chapter.   We don’t need L-systems to do the kind of work we’re doing here; however, they are incredibly useful because they provide a mechanism for keeping track of fractal structures that require complex and multi-faceted production rules.</p>
<p>In order to create an example that implements L-systems in Processing, we are going to have to be comfortable with working with (a) recursion, (b) transformation matrices, and (c) strings.    So far we’ve worked with recursion and transformations, but strings are new here.  We will assume the basics, but if that is not comfortable for you, I would suggest taking a look at the Processing tutorial <a href="http://www.processing.org/learning/text/">Strings and Drawing Text</a>.</p>
<p>An L-system involves three main components:</p>
<p><a id="alphabet-l-system-component-82eaa890-253f-0130-bd74-7cd1c3f718ad" style="display: block;"></a><a id="l-systemscomponents-of-82eaba00-253f-0130-bd75-7cd1c3f718ad" style="display: block;"></a><a id="natural-phenomenaplant-growth-modeling-82eda680-253f-0130-bd76-7cd1c3f718ad" style="display: block;"></a><a id="plant-growth-modeling-82edbb10-253f-0130-bd77-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Alphabet.</em></strong>  An L-system’s alphabet is comprised of the valid characters that can be included.  For example, we could say the alphabet is “ABC,” meaning that any valid “sentence” (a string of characters) in an L-system can only include these three characters.
</p>
</li>
		
	</ul>
</div><p><a id="axiom-l-system-component-82edda70-253f-0130-bd78-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Axiom.</em></strong>  The axiom is a sentence (made up with characters from the alphabet) that describes  the initial state of the system.  For example, with the alphabet “ABC,” some example axioms are “AAA” or “B” or “ACBAB.”
</p>
</li>
		
	</ul>
</div><p><a id="rules-l-system-component-82edf6b0-253f-0130-bd79-7cd1c3f718ad" style="display: block;"></a></p>
<div class="list">
	
	<ul>
		
			<li><p><strong><em>Rules.</em></strong>  The rules of an L-system are applied to the axiom and then applied recursively, generating new sentences over and over again.  An L-system rule includes two sentences, a “predecessor” and a “successor.”  For example, with the Rule “A —> AB”, whenever an “A” is found in a string, it is replaced with “AB.”
</p>
</li>
		
	</ul>
</div><p>Let’s begin with a very simple L-system.  (This is, in fact, Lindenmayer’s original L-system for modeling the growth of algae.)</p>
<a id="chapter08_figure24" style="display: block;"></a><div class="image-container half-width-right" >
	
	<img src="/book/imgs/chapter08/ch08_24.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.24: And so on and so forth...</p>
</div>
<p><span class="formula">Alphabet: A B</span><br /><span class="formula">Axiom:  A</span><br /><span class="formula">Rules:  (A → AB)  (B → A)</span></p>
<p>As with our recursive fractal shapes, we can consider each successive application of the L-system rules to be a generation.  Generation 0 is, by definition, the axiom.</p>
<p>Let’s look at how we might create these generations with code.  We’ll start by using a <span class="klass">String</span> object to store the axiom.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>String current = "A";</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">String</span> <span class="n">current</span> <span class="o">=</span> <span class="s">&quot;A&quot;</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>And once again, just as we did with the Game of Life and the Koch curve <span class="klass">ArrayList</span> examples, we will need an entirely separate string to keep track of the “next” generation.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>String next = "";</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">String</span> <span class="n">next</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Now it’s time to apply the rules to the current generation and place the results in the next.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>for (int i = 0; i < current.length(); i++) {
  char c = current.charAt(i);
  // Production rule A --> AB
  if (c == 'A') {
    next += "AB";
  // Production rule B --> A
  } else if (c == 'B') {
    next += "A";
  }
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Production rule A --> AB</div><code><pre><span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">next</span> <span class="o">+=</span> <span class="s">&quot;AB&quot;</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Production rule B --> A</div><code><pre><span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">next</span> <span class="o">+=</span> <span class="s">&quot;A&quot;</span><span class="o">;</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>And when we’re done, current can become next.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>current = next;</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>To be sure this is working, let’s package it into a function and and call it every time the mouse is pressed.</p>
<div class="image-container screenshot" >
	
	<img src="/book/imgs/chapter08/ch08_ex08.png" alt="Nature of Code Image" />
	
	
</div>
<p><a id="chapter08_example9" style="display: block;"></a><span class="example">Example 8.9: Simple L-system sentence generation</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>// Start with an axiom.
String current = "A";
// Let’s keep track of how many generations.
int count = 0;

void setup() {
  println("Generation " + count + ": " + current);
}

void draw() {
}

void mousePressed() {
  String next = "";
  // Traverse the current String and make the new one.
  for (int i = 0; i < current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      next += "AB";
    }  else if (c == 'B') {
      next += "A";
    }
  }
  current = next;
  count++;
  println("Generation " + count + ": " + current);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>Start with an axiom.</div><code><pre><span class='one-line'><span class="n">String</span> <span class="n">current</span> <span class="o">=</span> <span class="s">&quot;A&quot;</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Let’s keep track of how many generations.</div><code><pre><span class='one-line'><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Generation &quot;</span> <span class="o">+</span> <span class="n">count</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">current</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">mousePressed</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">String</span> <span class="n">next</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">;</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Traverse the current String and make the new one.</div><code><pre><span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">next</span> <span class="o">+=</span> <span class="s">&quot;AB&quot;</span><span class="o">;</span></span>
<span class='one-line'>    <span class="o">}</span>  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">next</span> <span class="o">+=</span> <span class="s">&quot;A&quot;</span><span class="o">;</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span>
<span class='one-line'>  <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="o">;</span></span>
<span class='one-line'>  <span class="n">count</span><span class="o">++;</span></span>
<span class='one-line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Generation &quot;</span> <span class="o">+</span> <span class="n">count</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">current</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>Since the rules are applied recursively to each generation, the length of the string grows exponentially.   By generation #11, the sentence is 233 characters long; by generation #22, it is over 46,000 characters long.   The Java <span class="klass">String</span> class, while convenient to use, is a grossly inefficient data structure for concatenating large strings.   A <span class="klass">String</span> object is “immutable,” which means once the object is created it can never be changed.  Whenever you add on to the end of a <span class="klass">String</span> object, Java has to make a brand new <span class="klass">String</span> object (even if you are using the same variable name).</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>String s = "blah";
s += "add some more stuff";</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;blah&quot;</span><span class="o">;</span></span>
<span class='one-line'><span class="n">s</span> <span class="o">+=</span> <span class="s">&quot;add some more stuff&quot;</span><span class="o">;</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p><a id="stringbuffer-class-82ee8b00-253f-0130-bd7a-7cd1c3f718ad" style="display: block;"></a><a id="stringsstringbuffer-class-vs-82ee9880-253f-0130-bd7b-7cd1c3f718ad" style="display: block;"></a></p>
<p>In most cases, this is fine, but why duplicate a 46,000-character string if you don’t have to?   For better efficiency in our L-system examples, we’ll use the <span class="klass">StringBuffer</span> class, which is optimized for this type of task and can easily be converted into a string after concatenation is complete.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>  // A StringBuffer for the “next” sentence
  StringBuffer next = new StringBuffer();
  for (int i = 0; i < current.length(); i++) {
    char c = current.charAt(i);
    if (c == 'A') {
      // append() instead of +=
      next.append("AB");
    } else if (c == 'B') {
      next.append("A");
    }
  }
  // StringBuffer can easily be converted
  // back to a String.
  current = next.toString();</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair '><div class='code-comment '>A StringBuffer for the “next” sentence</div><code><pre><span class='one-line'>  <span class="n">StringBuffer</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuffer</span><span class="o">();</span></span>
<span class='one-line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span></span>
<span class='one-line'>    <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="o">)</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>append() instead of +=</div><code><pre><span class='one-line'>      <span class="n">next</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;AB&quot;</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;B&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>      <span class="n">next</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;A&quot;</span><span class="o">);</span></span>
<span class='one-line'>    <span class="o">}</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>StringBuffer can easily be converted
back to a String.</div><code><pre><span class='one-line'>  <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>You may find yourself wondering right about now: what exactly is the point of all this?  After all, isn’t this a chapter about <em>drawing</em> fractal patterns?   Yes, the recursive nature of the L-system sentence structure seems relevant to the discussion, but how exactly does this model plant growth in a visual way?</p>
<p>What we’ve left unsaid until now is that embedded into these L-system sentences are instructions for drawing.   Let’s see how this works with another example.</p>
<p><span class="formula">Alphabet: A B</span><br /><span class="formula">Axiom:    A</span><br /><span class="formula">Rules:    (A → ABA)  (B → BBB)</span></p>
<p>To read a sentence, we’ll translate it in the following way:</p>
<p><span class="formula">A:  Draw a line forward.</span><br /><span class="formula">B:  Move forward without drawing.</span></p>
<p>Let’s look at the sentence of each generation and its visual output.</p>
<p><span class="formula">Generation 0: A</span><br /><span class="formula">Generation 1: ABA</span><br /><span class="formula">Generation 2: ABABBBABA</span><br /><span class="formula">Generation 3: ABABBBABABBBBBBBBBABABBBABA</span></p>
<p><a id="cantor-setl-systems-and-82ef0150-253f-0130-bd7c-7cd1c3f718ad" style="display: block;"></a></p>
<p>Look familiar?  This is the Cantor set generated with an L-system.</p>
<a id="chapter08_figure25" style="display: block;"></a><div class="image-container " >
	
	<img src="/book/imgs/chapter08/ch08_25.png" alt="Nature of Code Image" />
	
	<p class="caption">Figure 8.25</p>
</div>
<p>The following alphabet is often used with L-systems: “FG+-[]”, meaning:</p>
<p><span class="formula">F:  Draw a line and move forward</span><br /><span class="formula">G:  Move forward (without drawing a line)</span><br /><span class="formula">+:  Turn right</span><br /><span class="formula">-:  Turn left</span><br /><span class="formula">[:  Save current location</span><br /><span class="formula">]:  Restore previous location</span></p>
<p><a id="turtle-graphics-82ef4ac0-253f-0130-bd7d-7cd1c3f718ad" style="display: block;"></a></p>
<p>This type of drawing framework is often referred to as “Turtle graphics” (from the old days of LOGO programming).   Imagine a turtle sitting on your computer screen to which you could issue a small set of commands: turn left, turn right, draw a line, etc.  Processing isn’t set up to operate this way by default, but by using <span class="function">translate()</span>, <span class="function">rotate()</span>, and <span class="function">line()</span>, we can emulate a Turtle graphics engine fairly easily.</p>
<p><a id="l-systemstranslating-into-code-82ef7860-253f-0130-bd7e-7cd1c3f718ad" style="display: block;"></a></p>
<p>Here’s how we would translate the above L-system alphabet into Processing code.</p>
<p><span class="formula">F:  line(0,0,0,len); translate(0,len);</span><br /><span class="formula">G:  translate(0,len);</span><br /><span class="formula">+:  rotate(angle);</span><br /><span class="formula">-:  rotate(-angle);</span><br /><span class="formula">[:  pushMatrix();</span><br /><span class="formula">]:  popMatrix();</span></p>
<p>Assuming we have a sentence generated from the L-system, we can walk through the sentence character by character and call the appropriate function as outlined above.</p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>for (int i = 0; i < sentence.length(); i++) {

  // Looking at each character one at a time
  char c = sentence.charAt(i);

  //[full] Performing the correct task for each character.
  // This could also be written with a “case” statement,
  // which might be nicer to look at, but leaving it as an
  // if/else if structure helps readers not familiar with case statements.
  if (c == 'F') {
    line(0,0,len,0);
    translate(len,0);
  } else if (c == 'F') {
   translate(len,0);
  } else if (c == '+') {
    rotate(theta);
  } else if (c == '-') {
    rotate(-theta);
  } else if (c == '[') {
    pushMatrix();
  } else if (c == ']') {
    popMatrix();
  }
  //[end]
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sentence</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Looking at each character one at a time</div><code><pre><span class='one-line'>  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">sentence</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair stretch'><div class='code-comment stretch'> Performing the correct task for each character.
This could also be written with a “case” statement,
which might be nicer to look at, but leaving it as an
if/else if structure helps readers not familiar with case statements.</div><code><pre><span class='one-line'>  <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">line</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="n">len</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>    <span class="n">translate</span><span class="o">(</span><span class="n">len</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;F&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>   <span class="n">translate</span><span class="o">(</span><span class="n">len</span><span class="o">,</span><span class="mi">0</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">rotate</span><span class="o">(-</span><span class="n">theta</span><span class="o">);</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;[&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">pushMatrix</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span><span class="o">)</span> <span class="o">{</span></span>
<span class='one-line'>    <span class="n">popMatrix</span><span class="o">();</span></span>
<span class='one-line'>  <span class="o">}</span></span></pre></code><div style='position:relative;clear:both;display:block;height:1px;width:100%;'></div></div>

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><p>The next example will draw a more elaborate structure with the following L-system.</p>
<p><span class="formula">Alphabet:   FG+-[]</span><br /><span class="formula">Axiom:  F</span><br /><span class="formula">Rules:  F -→ FF+[+F-F-F]-[-F+F+F]</span></p>
<p>The example available for download on the book’s website takes all of the L-system code provided in this section and organizes it into three classes:</p>
<div class="list">
	
	<ul>
		
			<li><p><span class="mono">Rule</span>:  A class that stores the predecessor and successor strings for an L-system rule.
</p>
</li>
		
			<li><p><span class="mono">LSystem</span>: A class to iterate a new L-system generation (as demonstrated with the <span class="klass">StringBuffer</span> technique).
</p>
</li>
		
			<li><p><span class="mono">Turtle</span>: A class to manage reading the L-system sentence and following its instructions to draw on the screen.
</p>
</li>
		
	</ul>
</div><p>We won’t write out these classes here since they simply duplicate the code we’ve already worked out in this chapter. However, let’s see how they are put together in the main tab.</p>
<div class="image-container screenshot" >
	
	<img src="/book/imgs/chapter08/ch08_ex09.png" alt="Nature of Code Image" />
	
	
</div>
<p><a id="chapter08_example10" style="display: block;"></a><span class="example">Example 8.10: LSystem</span></p>
<div class="source-code">
  <a class="toggle" href="#" data-to-raw='Show Raw' data-to-formatted='Show Formatted'>Show Raw</a>
  <textarea>LSystem lsys;
Turtle turtle;

void setup() {
  size(600,600);

  // A ruleset is an array of Rule objects.
  Rule[] ruleset = new Rule[1];
  ruleset[0] = new Rule('F',"FF+[+F-F-F]-[-F+F+F]");

  // The L-system is created with an axiom and a ruleset.
  lsys = new LSystem("F",ruleset);

  //[offset-down] The Turtle graphics renderer is given a sentence,
  // a starting length, and an angle for rotations.
  turtle = new Turtle(lsys.getSentence(),width/4,radians(25));
}

void draw() {
  background(255);
  // Start at the bottom of the window and draw.
  translate(width/2,height);
  turtle.render();
}

void mousePressed() {
  // Generate a new sentence when the mouse is pressed.
  lsys.generate();
  turtle.setToDo(lsys.getSentence());

  // The length shrinks each generation.
  turtle.changeLen(0.5);
}</textarea>
  
  
  
  <div class="code-block">

  <div class='code-comment-pair no-comment'><code><pre><span class='one-line'><span class="n">LSystem</span> <span class="n">lsys</span><span class="o">;</span></span>
<span class='one-line'><span class="n">Turtle</span> <span class="n">turtle</span><span class="o">;</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">size</span><span class="o">(</span><span class="mi">600</span><span class="o">,</span><span class="mi">600</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>A ruleset is an array of Rule objects.</div><code><pre><span class='one-line'>  <span class="n">Rule</span><span class="o">[]</span> <span class="n">ruleset</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rule</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span></span>
<span class='one-line'>  <span class="n">ruleset</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rule</span><span class="o">(</span><span class="sc">&#39;F&#39;</span><span class="o">,</span><span class="s">&quot;FF+[+F-F-F]-[-F+F+F]&quot;</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The L-system is created with an axiom and a ruleset.</div><code><pre><span class='one-line'>  <span class="n">lsys</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LSystem</span><span class="o">(</span><span class="s">&quot;F&quot;</span><span class="o">,</span><span class="n">ruleset</span><span class="o">);</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair offset-down'><div class='code-comment '> The Turtle graphics renderer is given a sentence,
a starting length, and an angle for rotations.</div><code><pre><span class='one-line'>  <span class="n">turtle</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Turtle</span><span class="o">(</span><span class="n">lsys</span><span class="o">.</span><span class="na">getSentence</span><span class="o">(),</span><span class="n">width</span><span class="o">/</span><span class="mi">4</span><span class="o">,</span><span class="n">radians</span><span class="o">(</span><span class="mi">25</span><span class="o">));</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">draw</span><span class="o">()</span> <span class="o">{</span></span>
<span class='one-line'>  <span class="n">background</span><span class="o">(</span><span class="mi">255</span><span class="o">);</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Start at the bottom of the window and draw.</div><code><pre><span class='one-line'>  <span class="n">translate</span><span class="o">(</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">,</span><span class="n">height</span><span class="o">);</span></span>
<span class='one-line'>  <span class="n">turtle</span><span class="o">.</span><span class="na">render</span><span class="o">();</span></span>
<span class='one-line'><span class="o">}</span></span>
<span class='one-line'> </span>
<span class='one-line'><span class="kt">void</span> <span class="nf">mousePressed</span><span class="o">()</span> <span class="o">{</span></span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>Generate a new sentence when the mouse is pressed.</div><code><pre><span class='one-line'>  <span class="n">lsys</span><span class="o">.</span><span class="na">generate</span><span class="o">();</span></span>
<span class='one-line'>  <span class="n">turtle</span><span class="o">.</span><span class="na">setToDo</span><span class="o">(</span><span class="n">lsys</span><span class="o">.</span><span class="na">getSentence</span><span class="o">());</span></span>
<span class='one-line'> </span></pre></code></div>

  <div class='code-comment-pair '><div class='code-comment '>The length shrinks each generation.</div><code><pre><span class='one-line'>  <span class="n">turtle</span><span class="o">.</span><span class="na">changeLen</span><span class="o">(</span><span class="mf">0.5</span><span class="o">);</span></span>
<span class='one-line'><span class="o">}</span></span></pre></code></div>

</div>
  <div style="position: relative;clear:both;display:block;height:1px;width:100%;"></div>
</div><div class="example">
  <h4 id="exercise-812">Exercise 8.12</h4><p>Use an L-system as a set of instructions for creating objects stored in an <span class="klass">ArrayList</span>.  Use trigonometry and vector math to perform the rotations instead of matrix transformations (much like we did in the Koch curve example).</p>

</div><p><a id="algorithmic-beauty-of-plants-the-prusinkiewiczlindenmayer-82f00d20-253f-0130-bd7f-7cd1c3f718ad" style="display: block;"></a><a id="lindenmayer-aristid-82f01d70-253f-0130-bd80-7cd1c3f718ad" style="display: block;"></a><a id="prusinkiewicz-przemysaw-82f02af0-253f-0130-bd81-7cd1c3f718ad" style="display: block;"></a></p>
<div class="example">
  <h4 id="exercise-813">Exercise 8.13</h4><p>The seminal work in L-systems and plant structures, <em>The Algorithmic Beauty of Plants</em> by Przemysław Prusinkiewicz and Aristid Lindenmayer, was published in 1990.  It is available for free in its entirety <a href="http://algorithmicbotany.org/papers/#abop">online</a>.  Chapter 1 describes many sophisticated L-systems with additional drawing rules and available alphabet characters.  In addition, it describes several methods for generating stochastic L-systems.   Expand the L-system example to include one or more additional features described by Prusinkiewicz and Lindenmayer.</p>

</div><div class="example">
  <h4 id="exercise-814">Exercise 8.14</h4><p>In this chapter, we emphasized using fractal algorithms for generating visual patterns. However, fractals can be found in other creative mediums.  For example, fractal patterns are evident in Johann Sebastian Bach’s Cello Suite no. 3.  The structure of David Foster Wallace’s novel <em>Infinite Jest</em> was inspired by fractals.  Consider using the examples in this chapter to generate audio or text.</p>

</div><div class="tip">
  <h4 id="the-ecosystem-project">The Ecosystem Project</h4><p>Step 8 Exercise:</p>
<p>Incorporate fractals into your ecosystem.  Some possibilities:</p>
<div class="list">
	
	<ul>
		
			<li><p>
Add plant-like creatures to the ecosystem environment.
</p>
</li>
		
			<li><p>
Let’s say one of your plants is similar to a tree.  Can you add leaves or flowers to the end of the branches?   What if the leaves can fall off the tree (depending on a wind force)?  What if you add fruit that can be picked and eaten by the creatures?
</p>
</li>
		
			<li><p>
Design a creature with a fractal pattern.
</p>
</li>
		
			<li><p>
Use an L-system to generate instructions for how a creature should move or behave.
</p>
</li>
		
	</ul>
</div>
</div><div style="page-break-after:always;"> </div></section>
  	</div>
  </div>

	<div id="bottom">
		<div id="footer">
			<div class="one-third" id="licenses">
        <h4>Licenses</h4>
        <p>
          <a class="license-badge" rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a>
          <a class="license-badge" rel="license" href="http://creativecommons.org/licenses/LGPL/2.1/"><img alt="LGPL License" style="border-width:0" src="http://www.gnu.org/graphics/lgplv3-88x31.png" /></a>
        </p>

        <p>
          The book's text and illustrations are licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.
        </p>

        <p>
          All of the book's source code is licensed under the <a rel="license" href="http://creativecommons.org/licenses/LGPL/2.1/">GNU Lesser General Public License</a> as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.
        </p>

      </div>

      <div class="one-third">
        <h4>Colophon</h4>

        <p>This book was generated with <a href="https://github.com/runemadsen/Magic-Book-Project">The Magic Book Project</a>.

        <p>This book would not have been possible without the generous support of <a href="http://www.kickstarter.com/projects/shiffman/the-nature-of-code-book-project">Kickstarter</a> backers.</p> 

        <p>This book is typeset on the web in Georgia with headers in Proxima Nova.</p>

        <p>Please report any mistakes in the book or bugs in the source with a <a href="https://github.com/shiffman/The-Nature-of-Code/issues?sort=created&state=open">GitHub issue</a> or contact me at <span class="eml">daniel at shiffman dot net</span>.</p>
      </div>

      <div class="one-third">
        <h4>Author</h4>
        <p>Daniel Shiffman is a professor of the <a href="http://itp.nyu.edu/">Interactive Telecommunications Program</a> at New York University.</p>

        <p>He is the author of <a href="http://www.learningprocessing.com/">Learning Processing</a>.</p>

        <p><a href="https://twitter.com/shiffman">Twitter</a> <a href="http://github.com/shiffman">GitHub</a></p>
      </div>
		</div>
	</div>
</body>
</html>